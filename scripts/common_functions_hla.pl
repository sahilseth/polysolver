#!/usr/bin/perl

use strict;

#use diagnostics;

#######

sub getWtPeptides{ #start sub getWtPeptides

	my ($wt9MerFile,$wt10MerFile) = @_;

	my ($line,@arr,%hash,@arr2);

	@arr = ();

	%hash = ();

	open FILE, $wt9MerFile || die "getWtPeptides: Cannot open $wt9MerFile\n";
	
	while($line = <FILE>){

		chomp($line);

		push @arr, $line;

		$hash{$line} = 1;

	}

	close FILE;

	open FILE, $wt10MerFile || die "getWtPeptides: Cannot open $wt10MerFile\n";
	
	while($line = <FILE>){

		chomp($line);

		push @arr, $line;

		$hash{$line} = 1;

	}

	close FILE;

	@arr2 = (\@arr,\%hash);

	return \@arr2;

} # end sub getWtPeptides

#######

sub procGenomicSeq{ #start sub procGenomicSeq

	# function takes as input 
		# hashRef: a hash of the type generated by procGenomicChange
			# that has type, chr, n, pos, orig, changes 
		# genomeDir, chr: the chr file location
		# window: the genomic window required around the change
			# Note: total fetched length = 2*window + len(changed bases)
		# markChange: specifies whether the changed bases should be marked 
			# in parenthesis or not
		
	# It then goes to the genomic (chr) file, fetches the bases there and checks whether
	# the orig bases in the chr file and the ones in the hash are the same 	
	# it then fetches the region around the change (specified in bp in the input window)
	# argument, makes the changes and returns the changed sequence
	
	# this is function also takes output from procGenomicChange0 in get_genomic_region1.pl 
	# which is a specialized script for a new format that Lili submitted data in once
	
	# if markChange == 0 don't mark changes in parenthesis
	#		== 1 mark changes in parenthesis

	my ($genomeDir,$chr,$hashRef,$window,$markChange) = @_;

	my (@orig,$type,$chr,$n,@pos,@changes,$file,$s1,$s2,$seq);

	my ($bases,$seqBases,$minPos,$maxPos,$origBases);
	
	$type = $hashRef->{'type'};

	$chr = $hashRef->{'chr'};

	$n = $hashRef->{'n'};

	@pos = @{$hashRef->{'pos'}};

	@orig = @{$hashRef->{'orig'}};
	
	@changes = @{$hashRef->{'changes'}};
	
	$file = $genomeDir."/".$chr.".txt";

	open FILE, $file || die "Cannot open $file";

	if($type eq "del"){
		
		$minPos = min(@pos);
		
		$maxPos = max(@pos);
	
		seek(FILE,($minPos-1-$window),0);
		
		read(FILE,$s1,$window,0);

		seek(FILE,$maxPos,0);

		read(FILE,$s2,$window,0);

		$bases = join('',@orig);	
	
		seek(FILE,$minPos-1,0);
		
		read(FILE,$seqBases,length($bases));

		$bases =~ tr/a-z/A-Z/;
		
		$seqBases =~ tr/a-z/A-Z/;
			
		print "bases=$bases\tseqBases=$seqBases\n";

		if($bases ne $seqBases){
			
			die "del: $bases ne $seqBases\n";
		}

		if($markChange == 0){
		
			$seq = $s1.$s2;
	
		} else{

			$seq = $s1."[]".$s2;

		}

	}elsif($type eq "ins"){
		
		$minPos = min (@pos);
		
		$maxPos = max (@pos);
	
		seek(FILE,($minPos-$window),0);
		
		read(FILE,$s1,$window,0);

		seek(FILE,($maxPos-1),0);

		read(FILE,$s2,$window,0);
	
		$bases = join('',@changes);	

		print "bases=$bases\n";

		if($markChange==0){

			$seq = $s1.$bases.$s2;
		
		} else {
			
			$seq = $s1."[".$bases."]".$s2;
		
		}	
				
	}elsif($type eq "mut"){
		
		$minPos = min(@pos);
		
		$maxPos = max(@pos);
	
		seek(FILE,($minPos-1-$window),0);

		read(FILE,$s1,$window,0);

		seek(FILE,$maxPos,0);

		read(FILE,$s2,$window,0);
	
		$bases = join('',@changes);	

		$origBases = join('',@orig);

		seek(FILE,$minPos-1,0);
		
		read(FILE,$seqBases,length($origBases));

		$bases =~ tr/a-z/A-Z/;

		$origBases =~ tr/a-z/A-Z/;
		
		$seqBases =~ tr/a-z/A-Z/;
		
		print "bases=$bases\torigBases=$origBases\tseqBases=$seqBases\n";

		if($origBases ne $seqBases){
			
			die "mut: $origBases ne $seqBases\n";
		}

		if($markChange == 0){

			$seq = $s1.$bases.$s2;
		
		} else {

			$seq = $s1."[$origBases|$bases]".$s2;

		}
		
	} else {
		
		die "unknown type: $type\n";
	}


	close FILE;	

	return $seq;
 
} #end sub procGenomicSeq

#######

sub getPeptideLine{ # start sub getPeptideLine
	
	# function takes the following input
		# seq: nucleotide sequence
		# cdsStart: cds start position 0-base
		
	# it returns the peptide sequence that would align with the input DNA sequence
	# such that for each codon the corresponding amino acid lines up with the middle
	# nucleotide
	
	my ($seq,$cdsStart) = @_;
	
	my ($peptide,$cdsLength,$stopPos,$peptideTerminated,@arr,$i,$firstPos,$peptideLine);
	
	($peptide,$cdsLength,$stopPos,$peptideTerminated) = 
			@{getPeptide($seq,$cdsStart)};
		
	if($peptide=~/^$/){
		
		print "ERROR: getPeptideLine: peptide=$peptide\nseq=$seq\ncdsStart=$cdsStart\n";
		
		$peptideLine = "NA";

		return $peptideLine;

	}	
		
	@arr = split(//,$peptide);
			 
	$firstPos = $cdsStart + 1;
	
	$peptideLine="";
	
	for($i=0; $i < $firstPos;$i++){
		
		$peptideLine = $peptideLine." ";
		
	}
	
	for($i=0; $i<=$#arr; $i++){
		
		if($i == 0){

			$peptideLine = $peptideLine.$arr[$i];
	
		} else {
			
			$peptideLine = $peptideLine."  ".$arr[$i];
			
		}	
		
		
	}
		
	return $peptideLine;
		



} # end sub getPeptideLine

#######

sub getPeptide { # start sub getPeptide
	
	# this function taken in a DNA sequence and cds start position and translates it
	# the cds start position has to be 0-base
	# it returns
		# peptide: the translated peptide
		# length: length in base pairs of the translated peptide
		# stopPos: the stop position of the codon in the original submitted sequence in bp
			# 0-base
			# inclusive of the stop codon
			# is -1 is peptideTerminated = 0
		# peptideTerminated: 1 if an in-frame stop codon was found, 0 otherwise
	
	
	# it then takes the changePoint and pepWindow arguments to get a pepWindow # peptides
	# around the changePoint position
	# if pepWindow == 0, it returns a 9-mer and 10-mer amino acid chain around the 
	# changePoint
	# for a 9-mer it takes 4 aa on either side of the changePoint + the changePoint
	# for a 10-mer it takes 5 aa upstream, changePoint and 4 aa downstream and also
	# 4 + 1 + 5
	# if a premature stop codon prevents the getting of the the peptide around the 
	# changePoint, an error flag is also returned
	
	my ($seq,$cdsStart) = @_;
	
	my (%codonMap,$i,$seq2,$length,$found,$codon,$aa,$peptide,$seq3,@arr,$stopPos);
	
	my ($peptideTerminated);
	
	if($cdsStart=~/^$/ || $cdsStart < 0){
	
		print "ERROR: getPeptide: cdsStart = $cdsStart\n";
		
		$peptide = "NA";
		
		$length = 0;
		
		$stopPos = -1;
		
		$peptideTerminated = 0;
		
		@arr = ($peptide,$length,$stopPos,$peptideTerminated);
	
		return \@arr;
	}
	
	%codonMap = %{codonMap(1)};
	
	# get new orf

	$seq2 = substr($seq,$cdsStart);

	#print "getPeptide:cdsStart=$cdsStart\nseq=$seq\nseq2=$seq2\n";
	
	$seq3 = ();
	
	$peptide = ();
	
	$length = 0;

	$found = 0;	

	$peptideTerminated = 0;
	
	#print "seq=$seq\nseq2=$seq2\n";
	
	while(!$found){

		$codon = substr($seq2,0,3);

		$codon =~ tr/a-z/A-Z/;
		
		if(length($codon) < 3){
			
			last;
			
		}
		$aa = $codonMap{$codon};
		
		#print "codon=$codon\naa=$aa\n";
		
		if($aa=~/^$/){
			
			die "ERROR: getPeptide:for cdsStart = $cdsStart codon=$codon aa=$aa in 
				seq2=$seq2 length=$length\n";
				
		}
		
		$length = $length + 3;

		$peptide = $peptide.$aa;
		
		#print "codon = $codon\n";

		if($codon eq "TGA" || $codon eq "TAG" || $codon eq "TAA"){

			$found = 1;

			last;

		}


		$seq2 = substr($seq2,3);

		if($seq2=~/^$/){
			
			last;
			
		}

	}

	if($found==1){
		
		$peptideTerminated = 1;
	}

	# peptide now has the full amino acid sequence
	
	print "getPeptide: peptide=$peptide\n";
		
	if($peptideTerminated){
		
			$stopPos = $cdsStart + $length;	
		
	} else{
		
			$stopPos = -1;
	}
	
	@arr = ($peptide,$length,$stopPos,$peptideTerminated);
	
	return \@arr;
	
	#die;
	
	# find the hla9 and hla10 peptides
	
		
	
	
} # end sub getPeptide

#######

sub processJunctionTranscriptPair { # start sub processJunctionTranscriptPair

	# pos1: base position of junction in transcript 1 (genomic coordinates)
	# pos2: base position of junction in transcript 2 (genomic coordinates)
		
	my ($gene1,$gene2,$chr1,$pos1,$strand1,$chr2,$pos2,$strand2,$dbh,$tr1,$tr2,
		$translate1,$translate2,$genomeDir,$window,$hgVersion,$addChr) = @_;

	my ($coords_gaf1,$featCoords_gaf1,$type_gaf1,$chr_gaf1,$start_gaf1,$end_gaf1,
		$strand_gaf1,$cdsStart_gaf1,$cdsEnd_gaf1);
	
	my ($coords_gaf2,$featCoords_gaf2,$type_gaf2,$chr_gaf2,$start_gaf2,$end_gaf2,
		$strand_gaf2,$cdsStart_gaf2,$cdsEnd_gaf2);

	my ($i,%hash,$start,$end,$strand,$chr,$l1,$l2,$posFS1_tr1,$cdsStartFS1_tr1,
		@exonsGenomicFS1_tr1,$posFS1_tr2,$cdsStartFS1_tr2,@exonsGenomicFS1_tr2,$trPos2);
	
	my (@f,@exonsGenomic1,@exonsGenomic2,@exonArr,$exonStart,$exonEnd,$hash,$found1,$found2);
	
	my ($curChr,$transitionPoint,$seq,$exonSeq,$totalLen,$exonLen,$reverse,$gene,$curGene);
	
	my ($seqLine,$changeLine,$exonLine,$seqLine2,$changeLine2,$exonLine2,$exonStr,$j,@arr);
		
	my ($peptide,$cdsLength,$stopPos,$peptideTerminated,$peptideLine);
	
	my ($phaseTr1,$phaseTr1c,$phaseTr2,$phaseTr2c);
	
	# Note: strand1,strand2 are F,R not +,-
	
	# pos1 and pos2 are the (genomic) junction positions from the Junction line
		
	# get gaf annotation for the transcript (_gaf)

	($coords_gaf1,$featCoords_gaf1,$type_gaf1,$chr_gaf1,$start_gaf1,$end_gaf1,
		$strand_gaf1,$cdsStart_gaf1,$cdsEnd_gaf1) = @{getGafAnnotation($tr1,$dbh,$hgVersion)};
	
	($coords_gaf2,$featCoords_gaf2,$type_gaf2,$chr_gaf2,$start_gaf2,$end_gaf2,
		$strand_gaf2,$cdsStart_gaf2,$cdsEnd_gaf2) = @{getGafAnnotation($tr2,$dbh,$hgVersion)};

	# get the FS1 junction and cds start positions for tr1
	
	@exonsGenomicFS1_tr1 = @{getGenomicExonsFS1($coords_gaf1,$strand_gaf1)};
	
	#print "processJunctionTranscriptPair: calling getGenomicPosFS1:\n";
	
	$posFS1_tr1 = getGenomicPosFS1($coords_gaf1,$strand_gaf1,$pos1);

	$cdsStartFS1_tr1 = getGenomicCdsPosFS1(\@exonsGenomicFS1_tr1,$strand_gaf1,
		$cdsStart_gaf1);

	# get the FS1 junction and cds start positions for tr2
	
	@exonsGenomicFS1_tr2 = @{getGenomicExonsFS1($coords_gaf2,$strand_gaf2)};
	
	#print "processJunctionTranscriptPair: calling getGenomicPosFS1:\n";

	$posFS1_tr2 = getGenomicPosFS1($coords_gaf2,$strand_gaf2,$pos2);

	$cdsStartFS1_tr2 = getGenomicCdsPosFS1(\@exonsGenomicFS1_tr2,$strand_gaf2,
	$cdsStart_gaf2);

	print "\n## tr1=$tr1\ttr2=$tr2\ttranslate1=$translate1\ttranslate2=$translate2\t";
	print "gene1=$gene1\tgene2=$gene2 ##\n\n";

	print "coords_gaf1 = $coords_gaf1\nstart_gaf1 = $start_gaf1\tend_gaf1 = $end_gaf1\n";
	
	print "cdsStart_gaf1 = $cdsStart_gaf1\tcdsEnd_gaf1 = $cdsEnd_gaf1\n";
	print "strand_gaf1 = $strand_gaf1\n";
	
	print "pos1 = $pos1\tposFS1_tr1 = $posFS1_tr1\tcdsStartFS1_tr1 = $cdsStartFS1_tr1\n";

	print "coords_gaf2 = $coords_gaf2\nstart_gaf2 = $start_gaf2\tend_gaf2 = $end_gaf2\n";
	
	print "cdsStart_gaf2 = $cdsStart_gaf2\tcdsEnd_gaf2 = $cdsEnd_gaf2\n";
	print "strand_gaf2 = $strand_gaf2\n";

	print "pos2 = $pos2\tposFS1_tr2 = $posFS1_tr2\tcdsStartFS1_tr2 = $cdsStartFS1_tr2\n";

	# check if the strand orientations for the genes and transcripts are compatible
	# between the gaf annotation and the Junction line annotation

	if( !( ($strand1 eq "F" & $strand_gaf1 eq "+") || 
		($strand1 eq "R" & $strand_gaf1 eq "-") ) ){
		
		print "ERROR: in processJunctionTranscriptPair: strand incompatibility:
			tr1 = $tr1\t gene1 = $gene1\t strand1 = $strand1\tstrand_gaf1 = $strand_gaf1\n";
		
	}

	if( !( ($strand2 eq "F" & $strand_gaf2 eq "+") || 
		($strand2 eq "R" & $strand_gaf2 eq "-") ) ){
		
		print "ERROR: in processJunctionTranscriptPair: strand incompatibility:
			tr1 = $tr2\t gene1 = $gene2\t strand2 = $strand2\tstrand_gaf2 = $strand_gaf2\n";
		
	}


	# get the exons for the two transcripts

	@f = split(/:/,$coords_gaf1);
		
	@exonsGenomic1 = split(/,/,$f[1]);	

	@f = split(/:/,$coords_gaf2);
		
	@exonsGenomic2 = split(/,/,$f[1]);	

	# get the new set of fusion exons
	
	@exonArr = ();

	$found1 = 0;
	
	$found2 = 0;

	if($strand_gaf1 eq "+"){  # if strand of tr1 is positive
		
		for($i = 0;$i <= $#exonsGenomic1; $i++){ # start iterating through exons of tr1
			
			@f = split(/-/,$exonsGenomic1[$i]);
			
			$exonStart = $f[0];
			
			$exonEnd = $f[1];
		
			if($exonEnd <= $pos1){

				#print "exonEnd=$exonEnd\n";

				#note: for gene1, we want exons *before* the junction point
								
				%hash = ();
				
				$hash{'start'} = $exonStart;

				$hash{'end'} = $exonEnd;
				
				$hash{'strand'} = $strand_gaf1;
				
				$hash{'chr'} = $chr1;
		
				$hash{'gene'} = $gene1;
				
				push @exonArr, { %hash };
								
				if($pos1==$exonEnd){
					
					$found1 = 1;
					
					#last;
					
				}
				
			}
			
		} # finish iterating through exons of tr1
		
		if($found1==0){
			
			die "ERROR 547: Did not find $pos1 in $coords_gaf1\n";

		}		
	
	
	} else { # if strand of tr1 is negative
				
		# note: this reverses the exon boundary pairs, so that for every exon, 
		# start is still < end

		@exonsGenomic1 = reverse @exonsGenomic1;
		
		for($i = 0;$i <= $#exonsGenomic1; $i++){ # start iterating through exons of tr1
			
			@f = split(/-/,$exonsGenomic1[$i]);
			
			$exonStart = $f[0];
			
			$exonEnd = $f[1];
			
			if($exonStart >= $pos1){
				
				#print "exonStart=$exonStart\n";
				
				%hash = ();
				
				$hash{'start'} = $exonStart;

				$hash{'end'} = $exonEnd;
				
				$hash{'strand'} = $strand_gaf1;
				
				$hash{'chr'} = $chr1;

				$hash{'gene'} = $gene1;
				
				push @exonArr, { %hash };
								
				if($pos1==$exonStart){
					
					$found1 = 1;
					
					#last;
					
				}
				
			}
			
		} # finish iterating through exons of tr1
		
		if($found1==0){
			
			die "ERROR 599: Did not find $pos1 in $coords_gaf1\n";

		}		
				
		
	} # end if strand of tr1 is negative
	


	if($strand_gaf2 eq "+"){  # if strand of tr2 is positive
		
		for($i = 0;$i <= $#exonsGenomic2; $i++){ # start iterating through exons of tr2
			
			@f = split(/-/,$exonsGenomic2[$i]);
			
			$exonStart = $f[0];
			
			$exonEnd = $f[1];
			
			if($exonStart >= $pos2){

				#print "exonStart=$exonStart\n";

				#note: for gene2, we want exons *after* the junction point
								
				%hash = ();
				
				$hash{'start'} = $exonStart;

				$hash{'end'} = $exonEnd;
				
				$hash{'strand'} = $strand_gaf2;
				
				$hash{'chr'} = $chr2;

				$hash{'gene'} = $gene2;

				push @exonArr, { %hash };
								
				if($pos2==$exonStart){
					
					$found2 = 1;
					
					#last;
				}
				
				
				
			}
			
		} # finish iterating through exons of tr2
		
		if($found2==0){
			
			die "ERROR 653: Did not find $pos2 in $coords_gaf2\n";

		}		
	
	
	} else { # if strand of tr2 is negative
			
		# note: this reverses the exon boundary pairs, so that for every exon, 
		# start is still < end

		@exonsGenomic2 = reverse @exonsGenomic2;
		
		for($i = 0;$i <= $#exonsGenomic2; $i++){ # start iterating through exons of gene2
			
			@f = split(/-/,$exonsGenomic2[$i]);
			
			$exonStart = $f[0];
			
			$exonEnd = $f[1];
			
			if($exonEnd <= $pos2){
			
				#print "exonEnd=$exonEnd\n";
				
				%hash = ();
				
				$hash{'start'} = $exonStart;

				$hash{'end'} = $exonEnd;
				
				$hash{'strand'} = $strand_gaf2;
				
				$hash{'chr'} = $chr2;

				$hash{'gene'} = $gene2;

				push @exonArr, { %hash };
												
				if($pos2==$exonEnd){
					
					$found2 = 1;
					
					#last;
					
				}
			
				
			}
			
		} # finish iterating through exons of tr2
		
		if($found2==0){
			
			die "ERROR 706: Did not find $pos2 in $coords_gaf2\n";

		}		
				
		
	} # end if strand of gene2 is negative
	

	# create the chimeric transcript

	$l1 = 0; # length from the first transcript
	
	$l2 = 0; # length from the second transcript
	
	$transitionPoint = 0;
	
	$totalLen = 0;
	
	$seq = ();

	$seqLine = (); # Note: will do seqLine = seq after processing the exons
	 	
	$changeLine = ();
		
	$exonLine = ();
		
	for($i = 0; $i <= $#exonArr; $i++){ # start iterating through each exon entry
		
		%hash = %{$exonArr[$i]};
		
		$start = $hash{'start'};
		
		$end = $hash{'end'};
		
		$strand = $hash{'strand'};
		
		$chr = $hash{'chr'};
		
		$gene = $hash{'gene'};
				
		$reverse = 0;
		
		if($strand eq "-"){
			
			$reverse = 1;
		}
		
		if($i==0){
			
			$curGene = $gene;			
	
		}
		
		$exonLen = $end - $start + 1;
		
		$totalLen = $totalLen + $exonLen;
			
		$exonSeq = getGenomicSeq($chr,$start,$end,$reverse,$genomeDir,$addChr);
		
		$seq = $seq.$exonSeq;
				
		#print "processJunctionTranscriptPair: exonSeq = $exonSeq\n$seq\n";

		if($curGene ne $gene){
			
			print "transitioning:\n";
			
			$transitionPoint = $totalLen - $exonLen;
	
			$curGene = $gene;
			
		}
		
		print "$start\t$end\t$strand\t$chr\t$exonLen\t$totalLen\n";
		
		# update exonLine
		
		$exonStr = "|";
		
		for($j = 0; $j < ($end - $start -1); $j++){
			
			$exonStr = $exonStr." ";
			
		}
		
		$exonStr = $exonStr."|";
		
		$exonLine = $exonLine.$exonStr;
		
	} # finish iterating through each exon entry	

	# update exonLine to mark the start codon of the first transcript if it's present
	# in the chimeric transcript
	
	if($cdsStart_gaf1 <= $transitionPoint){
		
		@arr = split(//,$exonLine);
		
		$arr[$cdsStart_gaf1-1] = "s";
		
		$exonLine = join("",@arr);
		
	}

	$seqLine = $seq;

	#print "processJunctionTranscriptPair: seqLine=$seqLine\ncdsStart_gaf1=$cdsStart_gaf1\n";
	###print "processJunctionTranscriptPair: transitionPoint=$transitionPoint\n";
	
	# see if there is an in-frame stop codon from the start codon. If so, mark the first
	# one in the exonLine
	
	#($peptide,$cdsLength,$stopPos,$peptideTerminated) = 
	#		@{getPeptide($seqLine,$cdsStart_gaf1-1,$transitionPoint,0)};

	($peptide,$cdsLength,$stopPos,$peptideTerminated) = 
			@{getPeptide($seqLine,$cdsStart_gaf1-1)};

	print "processJunctionTranscriptPair: seqLine=$seqLine\ncdsStart_gaf1=$cdsStart_gaf1\n";
	
	$peptideLine = getPeptideLine($seqLine,$cdsStart_gaf1-1);

	if($cdsStart_gaf1 > $transitionPoint || $cdsStart_gaf1=~/^$/){
		$peptide="";
		$peptideLine="";
	}	
		
	if($stopPos!=-1){
		
		@arr = split(//,$exonLine);
		
		$arr[$stopPos-1] = "p";
		
		$exonLine = join("",@arr);
		
		
	}

	if($cdsStart_gaf1=~/^$/){

		$exonLine =~ s/s//g;

		$exonLine =~ s/p//g;

	}


	# get changeLine
	
	for($i = 0; $i < ($transitionPoint-1); $i++){
		
		$changeLine = $changeLine." ";
		
	}
	
	$changeLine = $changeLine."tt";

	print "totalLen = $totalLen\ttransitionPoint = $transitionPoint\n";
	
	print "\n\n#### Visualization ####\n\n";
	
	#print "$seqLine\n$changeLine\n$exonLine\n\n";
	
	# find the phase of the transcripts
	
	($phaseTr1,$phaseTr1c) = @{basePhaseTranscript($tr1,$pos1,$genomeDir,$dbh,$hgVersion)};

	($phaseTr2,$phaseTr2c) = @{basePhaseTranscript($tr2,$pos2,$genomeDir,$dbh,$hgVersion)};
		
	# base position of exon junction in second transcript (cds coordinates)
	
	$trPos2 = trPosition($tr2,$pos2,$genomeDir,$dbh,$hgVersion);
		
	@arr = ($peptideLine,$seqLine,$changeLine,$exonLine,$cdsStart_gaf1,$transitionPoint,
		$strand_gaf1,$strand_gaf2,$phaseTr1,$phaseTr2,$cdsStart_gaf2,$trPos2);
	
	return \@arr;
	
} # end sub processJunctionTranscriptPair

#######

sub basePhaseTranscript { # start sub basePhaseTranscript

	# pos1: position of the base on the transcript (genomic coordinates)

	my ($tr1,$pos1,$genomeDir,$dbh,$hgVersion) = @_;

	my ($coords_gaf1,$featCoords_gaf1,$type_gaf1,$chr_gaf1,$start_gaf1,$end_gaf1,
		$strand_gaf1,$cdsStart_gaf1,$cdsEnd_gaf1);

	my ($posFS1_tr1,$cdsStartFS1_tr1,@exonsGenomicFS1_tr1,$posFS1_tr2,
		$cdsStartFS1_tr2,@exonsGenomicFS1_tr2,@exonsGenomic1);

	my ($check1,$check2,$phaseTr1,$phaseTr1c,@f,@arr,$newPos);

	($coords_gaf1,$featCoords_gaf1,$type_gaf1,$chr_gaf1,$start_gaf1,$end_gaf1,
		$strand_gaf1,$cdsStart_gaf1,$cdsEnd_gaf1) = @{getGafAnnotation($tr1,$dbh,$hgVersion)};

	# get the FS1 base and cds start positions for tr1
	
	$newPos = trPosition($tr1,$pos1,$genomeDir,$dbh,$hgVersion);
	
	#$cdsStartFS1_tr1 = getGenomicCdsPosFS1(\@exonsGenomicFS1_tr1,$strand_gaf1,
	#	$cdsStart_gaf1);
	
	($check1,$check2) = @{checkFusionTranscript($tr1,$pos1,$dbh,$hgVersion)};

	$phaseTr1 = -1;
	
	$phaseTr1c = -1;
	
	if($check2){
		
		$phaseTr1 = ($newPos - $cdsStart_gaf1 + 1) % 3;

		$phaseTr1c = 3 - $phaseTr1;
		
	}
	
	print "basePhaseTranscript: cdsStart_gaf1 = $cdsStart_gaf1\t";
	print "newPos = $newPos\ttr1=$tr1\tpos1=$pos1\n";

	@arr = ($phaseTr1,$phaseTr1c);

	return \@arr;

} # end sub basePhaseTranscript

#######

sub checkFusionTranscript{ # start sub checkFusionTranscript

	# function checks if for the given transcript and position 
		# the position is the junction of an exon in the transcript 
		# the cds start lies before the position in the transcript
		
	# pos: base position to be checked (genomic coordinates)

	my ($tr,$pos,$dbh,$hgVersion) = @_;

	my ($coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,$strand_gaf); 
	
	my ($cdsStart_gaf,$cdsEnd_gaf);

	my ($check1,$check2,@f,@exonsGenomic,$i,@boundaries,@arr,@exonsGenomicFS1);
	
	my ($cdsStartFS1,$posFS1,$ref);
	
	$ref = getGafAnnotation($tr,$dbh,$hgVersion);
	
	if($ref == 0){
		
		print "ERROR: checkFusionTranscript: $tr was not found in the database (coords)\n";
		
		@arr = (0,0);
		
		return \@arr;
		
	}
	($coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,
		$strand_gaf,$cdsStart_gaf,$cdsEnd_gaf) = @{$ref};

	$check1 = 0;
	
	$check2 = 0;
	
	#print "pos=$pos\n";
	
	#print "coords_gaf=$coords_gaf\nstart_gaf=$start_gaf\tend_gaf=$end_gaf\n
	#	cdsStart_gaf=$cdsStart_gaf\tcdsEnd_gaf=$cdsEnd_gaf\n";

	@exonsGenomicFS1 = @{getGenomicExonsFS1($coords_gaf,$strand_gaf)};
	
	#print "exonsGenomicFS1=@exonsGenomicFS1\n";
	
	@f = split(/:/,$coords_gaf);
		
	@exonsGenomic = split(/,/,$f[1]);	

	#print "exonsGenomic=@exonsGenomic\n";

	@boundaries = ();

	for($i = 0; $i <=$#exonsGenomic; $i++){
		
		@f = split(/-/,$exonsGenomic[$i]);
		
		push @boundaries, $f[0];
		
		push @boundaries, $f[1];
		
		#print "f=$f[0]\t$f[1]\n";
	}

	# check if the given junction position (genomic coordinates) is one of the 
	# exon boundaries of the transcript

	if(found_arr($pos,\@boundaries)){
		
		$check1 = 1;
		
	}

	# Note: not checking for whether the correct end of exon is matched. This is done in the 
	# getExonJunctionRegion function

	# check if the cdsStart < given exon junction
	# first convert both to FS1 coordinates
	
	$posFS1 = getGenomicPosFS1($coords_gaf,$strand_gaf,$pos);

	if($cdsStart_gaf=~/^$/){
		
		$cdsStartFS1 = "";
		
	} else{
	
		$cdsStartFS1 = getGenomicCdsPosFS1(\@exonsGenomicFS1,$strand_gaf,$cdsStart_gaf);
	
	}
	
	print "checkFusionTranscript: cdsStart_gaf = $cdsStart_gaf\tcdsStartFS1 = $cdsStartFS1\tcdsEnd_gaf = $cdsEnd_gaf\tstrand_gaf = $strand_gaf\t";

	print "pos = $pos\tposFS1 = $posFS1\n";

	#print "posFS1 = $posFS1\tcdsStartFS1 = $cdsStartFS1\n";

	if($cdsStart_gaf=~/^$/){

		$check2 = 0;
		
	} else{
 	
		if($cdsStartFS1 < $posFS1){
		
			$check2 = 1;
		
		}

	}
	
	@arr = ($check1, $check2);
	
	return \@arr;

} # end sub checkFusionTranscript

#######

sub getUcscTranscriptsForGeneJunction{ # start sub getUcscTranscriptsForGeneJunction
	
	# function takes the Junction line parameters + gene names from the rna.junctions.txt 
	# file as input and finds all corresponding (transcript1,transcript2) pairs that can be
	# used for fusion site primer design as well as all corresponding 
	# (transcript1,transcript2) pairs (subset of the junction design pairs) that can be used 
	# for getting the mutated peptide. The subsetting is done based on checking on 
	# the two criteria calculated in function checkFusionTranscript
	
	my ($gene1,$gene2,$chr1,$pos1,$strand1,$chr2,$pos2,$strand2,$dbh,$hgVersion) = @_;

	my ($coords_gaf1,$featCoords_gaf1,$type_gaf1,$chr_gaf1,$start_gaf1,$end_gaf1,
		$strand_gaf1,$cdsStart_gaf1,$cdsEnd_gaf1);
	
	my ($coords_gaf2,$featCoords_gaf2,$type_gaf2,$chr_gaf2,$start_gaf2,$end_gaf2,
		$strand_gaf2,$cdsStart_gaf2,$cdsEnd_gaf2);

	my ($sth,@row,$coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,
		$strand_gaf,$cdsStart_gaf,$cdsEnd_gaf);
	
	my ($nrows,@arr,$i,@trJunctionArr1,@trTranslateArr1,$tr,@trJunctionArr2,
		@trTranslateArr2,@row2);

	my($check1,$check2,@rowsAll,@r,@translateStatus1,@translateStatus2);
	
	# note: pos1 and pos2 are the exon boundary junctions for gene1 and gene2
	
	# note: strand1, strand2 are F,R not +,-
	
	# get transcripts that have valid junctions (and can be used for primer design) and 
	# transcripts that can be used for peptide generation for gene1

	print "\ngetUcscTranscriptsForGeneJunction:## gene1 = $gene1 ##\n\n";
	
	if($hgVersion eq "hg18"){
	
		$sth = $dbh->prepare(qq{SELECT kgID FROM kgXref_hg18_oncotator where 
			geneSymbol = '$gene1'});

	} elsif($hgVersion eq "hg19"){
	
		$sth = $dbh->prepare(qq{SELECT kgID FROM kgXref_hg19_oncotator where 
			geneSymbol = '$gene1'});

	} else{

		die "getUcscTranscriptsForGeneJunction: hgVersion == $hgVersion is invalid\n";

	}		

	$sth->execute() || die "Cannot execute $sth\n";

	@trJunctionArr1 = ();

	@trTranslateArr1 = ();
	
	@rowsAll = @{$sth->fetchall_arrayref};
	
	for($i=0;$i<=$#rowsAll;$i++){
		
		@r = @{$rowsAll[$i]};
		
		$tr = $r[0];
		
		print "\ngetUcscTranscriptsForGeneJunction: gene1 = $gene1\ttr = $tr\n\n";	

		# check if the transcript qualifies based on
			# is the exon with the fusion junction present in the transcript
			# does the cds start lie before the exon fusion junction
		
		$check1 = 0;
		
		$check2 = 0;
		
		#($coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,
		#	$strand_gaf,$cdsStart_gaf,$cdsEnd_gaf) = @{getGafAnnotation($tr,$dbh)};
		
		#@arr = @{getGafAnnotation($tr,$dbh,$hgVersion)};
		
		($check1,$check2) = @{checkFusionTranscript($tr,$pos1,$dbh,$hgVersion)};
		
		if($check1){
	
			push @trJunctionArr1, $tr;

			if($check2){
	
				push @trTranslateArr1, $tr;
	
				push @translateStatus1, 1;
	
			} else {
			
				push @translateStatus1, 0;
			
			}
		
	
		}
		
		print "\ngetUcscTranscriptsForGeneJunction: gene1 = $gene1\ttr = $tr\t$check1\t$check2\tpos1 = $pos1\n";
				
	}	

	$sth->finish(); 

	# get transcripts that have valid junctions (and can be used for primer design) and 
	# transcripts that can be used for peptide generation for gene2

	print "\n## gene2 = $gene2 ##\n\n";

	if($hgVersion eq "hg18"){
	
		$sth = $dbh->prepare(qq{SELECT kgID FROM kgXref_hg18_oncotator where 
			geneSymbol = '$gene2'});

	} elsif($hgVersion eq "hg19"){
	
		print "hg19:geneSymbol=$gene1\n";

		$sth = $dbh->prepare(qq{SELECT kgID FROM kgXref_hg19_oncotator where 
			geneSymbol = '$gene2'});

	} else{

		die "hgVersion == $hgVersion is invalid\n";

	}		
	
	$sth->execute() || die "Cannot execute $sth\n";

	@trJunctionArr2 = ();

	@trTranslateArr2 = ();
		
	@rowsAll = @{$sth->fetchall_arrayref};
	
	for($i=0;$i<=$#rowsAll;$i++){
		
		@r = @{$rowsAll[$i]};
		
		$tr = $r[0];
		
		print "\ngetUcscTranscriptsForGeneJunction: gene2 = $gene2\ttr = $tr\n\n";	
		
		# check if the transcript qualifies based on
			# is the exon with the fusion junction present in the transcript
			# does the cds start lie before the exon fusion junction
		
		$check1 = 0;
		
		$check2 = 0;
		
		#($coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,
			#$strand_gaf,$cdsStart_gaf,$cdsEnd_gaf) = @{getGafAnnotation($tr,$dbh)};
		
		#@arr = @{getGafAnnotation($tr,$dbh)};
		
		($check1,$check2) = @{checkFusionTranscript($tr,$pos2,$dbh,$hgVersion)};
		
		print "check1=$check1\n";
		
		if($check1){
	
			print "in if 1\n";
			
			push @trJunctionArr2, $tr;

			# Note:	for gene2, trJunction and trTranslate criteria
			# are the same

			push @trTranslateArr2, $tr;
	
			push @translateStatus2, 1;
	
		} 
		
		print "\ngetUcscTranscriptsForGeneJunction: gene2 = $gene2\ttr = $tr\t$check1\t$check2\tpos2 = $pos2\n";

	}

	$sth->finish(); 
		
	return (\@trJunctionArr1,\@trJunctionArr2,\@trTranslateArr1,\@trTranslateArr2,
		\@translateStatus1,\@translateStatus2);	

} # end sub getUcscTranscriptsForGeneJunction


#######

sub getGafAnnotationGeneName{ # start sub getGafAnnotationGeneName
	
	# here id_o is the gene name ex. RHOH
	# in the coords database the id for type=='gene' is of the form RHOH|399
	# so id_o will be modified to 'RHOH|' and we will use LIKE in the sql statement
	
	my ($id_o,$dbh,$exact,$hgVersion) = @_;

	my ($sth,@row,$coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,
		$strand_gaf,$cdsStart_gaf,$cdsEnd_gaf,$fetchRef);
	
	my ($nrows,@arr,$id_o_mod);

	if($exact==0){

		$id_o_mod = $id_o."|%";

    }elsif($exact==1){
    	
		$id_o_mod = $id_o;    	
 
    } else {
    	
    	die "getGafAnnotationGeneName: exact = $exact\n";
 
    }
	#$id_o_mod="uc001ceo.1";
	
	#print "id_o_mod=$id_o_mod\n";	

	if($hgVersion eq "hg18"){
	
		$sth = $dbh->prepare(qq{SELECT coordinates,feature_coordinates,type,chr,start,end,strand,
			cds_start,cds_end FROM coords where type = 'gene' and id LIKE '$id_o_mod'});

	} elsif($hgVersion eq "hg19"){
	
		$sth = $dbh->prepare(qq{SELECT coordinates,feature_coordinates,type,chr,start,end,strand,
			cds_start,cds_end FROM coords_hg19 where type = 'gene' and id LIKE '$id_o_mod'});
	}

	$sth->execute() or die "Can't excute SQL statement: $DBI::errstr\n";;

	$nrows = $sth->rows();
	
	#print "nrows=$nrows\n";
	
	$fetchRef = $sth->fetch or 	return -1;	

	@row = @{$fetchRef};
	
 	$coords_gaf = $row[0];		$featCoords_gaf = $row[1];	$type_gaf = $row[2];
 	$chr_gaf = $row[3];			$start_gaf = $row[4];		$end_gaf = $row[5];		
 	$strand_gaf = $row[6];
 	$cdsStart_gaf = $row[7];	$cdsEnd_gaf = $row[8];
	
	#print "row=@row\n";	

	# die if there are more than one rows for a given gene name
	
	$nrows = $sth->rows();
	#print "nrows=$nrows\n";
	if($nrows>1){
		die "ERROR: getGafAnnotationGeneName: more than one entry for id_o=$id_o\n";
	}elsif($nrows==0){
		print "ERROR: getGafAnnotationGeneName: no entries for id_o=$id_o\n";	
	}
	
	$sth->finish(); 

	@arr = ($coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,$strand_gaf,
		$cdsStart_gaf,$cdsEnd_gaf);

	return \@arr;

} # end sub getGafAnnotationGeneName


#######

sub getGafAnnotation{ # start sub getGafAnnotation
	
	# Note: id_o is the transcript id here ex. uc002qxe.1
	
	my ($id_o,$dbh,$hgVersion) = @_;

	my ($sth,@row,$coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,
		$strand_gaf,$cdsStart_gaf,$cdsEnd_gaf,@f,@exonsGenomic,$coords_gaf2,$i,@exonArr,$exon);
	
	my ($nrows,@arr,$ref);

	if($hgVersion eq "hg18"){

		$sth = $dbh->prepare(qq{SELECT coordinates,feature_coordinates,type,chr,start,end,
			strand,cds_start,cds_end FROM coords where id = '$id_o' and source != 'calculated'});

	}elsif($hgVersion eq "hg19"){
	
		$sth = $dbh->prepare(qq{SELECT coordinates,feature_coordinates,type,chr,start,end,
			strand,cds_start,cds_end FROM coords_hg19 where id = '$id_o' and source != 'calculated'});

	}

	$sth->execute() || die "Cannot execute $sth\n";

	#print "getGafAnnotation: id_o=$id_o\n";
	
	$ref = $sth->fetch;
	
	#print "ref=$ref\n";
	
	if(!defined($ref)){
	
		print "ERROR: getGafAnnotation: No entries found for id_o=$id_o\n";
	
		return 0;
		
	}
	@row = @{$ref};
	 	
 	$coords_gaf = $row[0];		$featCoords_gaf = $row[1];	$type_gaf = $row[2];
 	$chr_gaf = $row[3];			$start_gaf = $row[4];		$end_gaf = $row[5];		
 	$strand_gaf = $row[6];
 	$cdsStart_gaf = $row[7];	$cdsEnd_gaf = $row[8];
	
	#print "row=@row\n";	

	# die if there are more than one rows for a given ucsc transcript id that is 
	# not calculated
	
	$nrows = $sth->rows();
	print "nrows=$nrows\n";
	if($nrows>1){
		die "ERROR: getGafAnnotation: more than one entry for id_o=$id_o\n";
	}elsif($nrows==0){
		print "ERROR: getGafAnnotation: no entries for id_o=$id_o\n";	
	}
	
	$sth->finish(); 


	if($strand_gaf eq "-" & $hgVersion eq "hg19"){ # if strand_gaf is '-'

		$coords_gaf2 = ();

		@f = split(/:/,$coords_gaf);

		$coords_gaf2 = $f[0].":";
		
		@exonsGenomic = split(/,/,$f[1]);	

		@exonsGenomic = reverse @exonsGenomic;

		for($i = 0; $i <= $#exonsGenomic; $i++){
			
			$exon = $exonsGenomic[$i];
			
			@exonArr = split(/-/,$exon);

			if($i == 0){
			
				$coords_gaf2 = $coords_gaf2.$exonArr[1]."-".$exonArr[0];

			} else{	

				$coords_gaf2 = $coords_gaf2.",".$exonArr[1]."-".$exonArr[0];

			}
	
		}

		$coords_gaf2 = $coords_gaf2.":".$f[2];	

		$coords_gaf = $coords_gaf2;

		#print "coords_gaf2:$coords_gaf2\n";

	}


	@arr = ($coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,$strand_gaf,
		$cdsStart_gaf,$cdsEnd_gaf);

	return \@arr;

} # end sub getGafAnnotation

#######


sub procOncLine{ #start sub procOncLine
	
	#offset is usually 0, but maybe 1 if the sample name is included in the first column
	#version == 2 (oncotator) if cdnaChange_o is at position 38 instead of 39
	
	my ($line, $header) = @_;
	
	my (@f,$chr_o,$start_o,$end_o,$strand_o,$varClass_o, $varType_o,$gChange_o);
	
	my ($cdnaChange_o, $codonChange_o,$protChange_o,$id_o,@arr,$gene_o,$geneNum_o,@names,$name,$i);
	
	@f = split(/\t/,$line);

	#@names = split(/\s+/,$header);
	@names = split(/\t/,$header);

	for($i = 0; $i <= $#names; $i++){
		$name = $names[$i];
		if($name eq "Chromosome"){
			$chr_o = $f[$i];
		}
		if($name eq "Start_position"){
			$start_o = $f[$i];
		}
		if($name eq "End_position"){
			$end_o = $f[$i];
		}
		if($name eq "Strand"){
			$strand_o = $f[$i];
		}
		if($name eq "Variant_Classification"){
			$varClass_o = $f[$i];
		}
		if($name eq "Variant_Type"){
			$varType_o = $f[$i];
		}
		if($name eq "Genome_Change"){
			$gChange_o = $f[$i];
		}
		if($name eq "Hugo_Symbol"){
			$gene_o = $f[$i];
		}
		if($name eq "Entrez_Gene_Id"){
			$geneNum_o = $f[$i];
		}
		if($name eq "Annotation_Transcript"){
		#if($name eq 'i_HGNC_UCSC ID(supplied by UCSC)'){
			$id_o = $f[$i];
		}
		if($name eq "cDNA_Change"){
			$cdnaChange_o = $f[$i];
		}
		if($name eq "Codon_Change"){
			$codonChange_o = $f[$i];
		}
		if($name eq "Protein_Change"){
			$protChange_o = $f[$i];
		}


	}	

	@arr = ($chr_o,$start_o,$end_o, $strand_o,$varClass_o, $varType_o,$gChange_o,
		$cdnaChange_o,$codonChange_o,$protChange_o,$gene_o,$geneNum_o,$id_o);

	return \@arr;

} #end sub procOncLine

#######


#sub procOncLineSynapse{ #start sub procOncLineSynapse
#
#        #offset is usually 0, but maybe 1 if the sample name is included in the first column
#        #version == 2 (oncotator) if cdnaChange_o is at position 38 instead of 39
#
#        my ($line, $header) = @_;
#
#        my (@f,$chr_o,$start_o,$end_o,$strand_o,$varClass_o, $varType_o,$gChange_o);
#
#        my ($cdnaChange_o,$codonChange_o,$protChange_o,$id_o,@arr,$gene_o,$geneNum_o,@names,$name,$i,$c_position,$reference,$variant);
#
#        @f = split(/\t/,$line);
#
#        @names = split(/\s+/,$header);
#
#        for($i = 0; $i <= $#names; $i++){
#                $name = $names[$i];
#                if($name eq "Chromosome"){
#                        $chr_o = $f[$i];
#                }
#                if($name eq "Start_position"){
#                        $start_o = $f[$i];
#                }
#                if($name eq "End_position"){
#                        $end_o = $f[$i];
#                }
#                if($name eq "Strand"){
#                        $strand_o = $f[$i];
#                }
#                if($name eq "Variant_Classification"){
#                        $varClass_o = $f[$i];
#                }
#                if($name eq "Variant_Type"){
#                        $varType_o = $f[$i];
#                }
#                if($name eq "Genome_Change"){
#                        $gChange_o = $f[$i];
#                }
#                if($name eq "Hugo_Symbol"){
#                        $gene_o = $f[$i];
#                }
#                if($name eq "Entrez_Gene_Id"){
#                        $geneNum_o = $f[$i];
#                }
#                if($name eq "Annotation_Transcript"){
#                        $id_o = $f[$i];
#                }
#                if($name eq "cDNA_Change"){
#                        $cdnaChange_o = $f[$i];
#                }
#                if($name eq "Codon_Change"){
#                        $codonChange_o = $f[$i];
#                }
#                if($name eq "amino_acid_change"){
#                        $protChange_o = $f[$i];
#                }
#                if($name eq "c_position"){
#                        $c_position = $f[$i];
#                }
#                if($name eq "reference"){
#                        $reference = $f[$i];
#                }
#                if($name eq "variant"){
#                        $variant = $f[$i];
#                }
#
#	
#
#        }
#
#	if($varClass_o eq "Missense_Mutation" || $varClass_o eq "Nonsense_Mutation" || $varClass_o eq "Nonstop_Mutation" || $varClass_o eq "Silent"){
#
#		$cdnaChange_o = $c_position.$reference.">".$variant;
#	
#		$gChange_o = 
#
#	}
#
#        @arr = ($chr_o,$start_o,$end_o, $strand_o,$varClass_o, $varType_o,$gChange_o,
#                $cdnaChange_o,$codonChange_o,$protChange_o,$gene_o,$geneNum_o,$id_o);
#
#        return \@arr;
#
#} #end sub procOncLineSynapse


#######

sub procOncLineOld{ #start sub procOncLineOld
	
	#offset is usually 0, but maybe 1 if the sample name is included in the first column
	#version == 2 (oncotator) if cdnaChange_o is at position 38 instead of 39
	
	my ($line, $offset,$version) = @_;
	
	my (@f,$chr_o,$start_o,$end_o,$strand_o,$varClass_o, $varType_o,$gChange_o);
	
	my ($cdnaChange_o, $codonChange_o,$protChange_o,$id_o,@arr,$gene_o,$geneNum_o);
	
	@f = split(/\t/,$line);

	#print "f=@f\n";
	
	$chr_o = $f[$offset+4];			$start_o = $f[$offset+5];			
	$end_o = $f[$offset+6];	
	$strand_o = $f[$offset+7];
	$varClass_o = $f[$offset+8];		$varType_o = $f[$offset+9];
	$gChange_o = $f[32];
	
	$gene_o = $f[$offset+0];
	$geneNum_o = $f[$offset+1];
	$id_o = $f[$offset+33];
	
	if($version==1){	
		$cdnaChange_o = $f[$offset+38];	
		$codonChange_o = $f[$offset+39]; 	
		$protChange_o = $f[$offset+40];
	}elsif($version==2){
		$cdnaChange_o = $f[$offset+37];	
		$codonChange_o = $f[$offset+38]; 	
		$protChange_o = $f[$offset+39];				
	}elsif($version==3){
		$cdnaChange_o = $f[$offset+35];
		$codonChange_o = $f[$offset+36];
		$protChange_o = $f[$offset+37];	       
		
	}elsif($version==4){
		$gChange_o = $f[$offset+34];
		$id_o = $f[$offset+35];
		$cdnaChange_o = $f[$offset+39];
		$codonChange_o = $f[$offset+40];
		$protChange_o = $f[$offset+41];	       

	}else {
		die "ERROR: procOncLine: version = $version\n";
	}

	@arr = ($chr_o,$start_o,$end_o, $strand_o,$varClass_o, $varType_o,$gChange_o,
		$cdnaChange_o,$codonChange_o,$protChange_o,$gene_o,$geneNum_o,$id_o);

	return \@arr;

} #end sub procOncLineOld


#######

sub convertGChangeToIndelocator { # start sub convertGChangeToIndelocator

	# this function converts Strelka type genomic change annotations to Indelocator format
	# ex. 
	# g.chr1:203144707_203144708T>TGGGG to g.chr1:203144707_203144708insGGGG
	# g.chr20:8665595_8665595TG>T to g.chr20:8665596G # note increase in 1 of start position
	# g.chr15:78474411_78474412CTG>C  to g.chr15:78474412_78474413delTG # note increase in 1 of start position. end position should be determined by adding the change length to the start position
	
	my ($c) = @_;

	my (@f,$chr,$start,$end,$origBases,$bases);
	
	$c = substr($c,2);
	
	


} # end sub convertGChangeToIndelocator

#######

sub procGenomicChange{ #start sub procGenomicChange

	# this function can process both cdna and genomic oncotator changes
	# function returns a hash with the following information about the change:
		# type		: mut, ins, del
		# chr		: chromosome
		# n			: # bases that have changed
		# pos		: positions (in cdna or genome) at which the changes occur
		# orig		: original bases at pos 
		# changes	: changed bases at pos
		# Note: if the input is cdna change, then the chr field will be empty
	
	my ($c,$which) = @_;
	
	my (@f,$chr,@pos,$type,$n,%hash,$i,@range,$j,$bases,@changes,$t,@orig,$origBases,$change,$position);

	if(!($which eq "cdna" || $which eq "genomic")){
		
		die "ERROR: in procGenomicChange: which = $which c = $c\n";
	}

	$c = substr($c,2);

    print "c=$c\n";

	# get cType
	
	if($c=~/del/){
		
		$type = "del";

	}elsif($c=~/ins/){
		
		$type = "ins";
		
	}else{
		
		$type = "mut";
		
	}

	print "type=$type\n";
	
	# get chr if it's a genomic change

	if($which eq "genomic"){
		
		@f = split(/:/,$c);

		$chr = $f[0];

		print "chr=$chr\n";

		$change = $f[1];
	
	} else {
		
		$change = $c;
		
	}

	print "procGenomicChange: change=$change\n";
	
	@pos = ();

	@orig = ();

	@changes = ();
	
	$origBases = ();
	
	# get changes

	if($change=~/_/){ # if there is a more than one base change
		
		if($type eq "del"){
						
			$i = index($change,"del");
			
			$bases = substr($change,$i+3);
				
			$change = substr($change,0,$i);
			
			@range = split(/_/,$change);
			
			$n = $range[1] - $range[0] + 1;
			
			for($j = 0; $j < $n; $j++){
				
				$t = $range[0] + $j;
								
				push @pos, $t;

			}
			
			@orig = split(//,$bases);
	
			
		}elsif($type eq "ins"){
						
			$i = index($change,"ins");
			
			$bases = substr($change,$i+3);
			
			$change = substr($change,0,$i);
			
			@range = split(/_/,$change);
			
			$n = length($bases);
			
			for($j = 0; $j < $n; $j++){
				
				$t = $range[0] + $j;
								
				push @pos, $t;

			}
			
			@changes = split(//,$bases);	

		} elsif($type eq "mut") {
						
			$i = index($change,">");
			
			$bases = substr($change,($i+1));
			
			@changes = split(//,$bases);
			
			$change = substr($change,0,$i);
								
			for($j=0;$j<=$#changes;$j++){
				
				$origBases = $origBases.chop($change);
								
			}			

			$origBases = reverse($origBases);

			@orig = split(//,$origBases);

			@range = split(/_/,$change);
			
			$n = $range[1] - $range[0] + 1;
					
			for($j = 0; $j < $n; $j++){
				
				$t = $range[0] + $j;
								
				push @pos, $t;

			}

						
		} else {
			
			die "unknown type $type\n";

		}
				
		
	} else { # if there is only a single base change
		
		$n = 1;

		
		if($type eq "del"){
											
			$i = index($change,"del");
			
			$bases = substr($change,$i+3);
			
			$position = substr($change,0,$i);

			push @pos, $position;
			
			push @orig, $bases;

			push @changes, $bases;						

			print "change=$change, bases=$bases\n";
			
		}elsif($type eq "ins"){
						
			$i = index($change,"ins");
			
			$bases = substr($change,$i+3);
			
			$position = substr($change,0,$i);

			push @pos, $position;
			
			push @changes, $bases;

		} elsif($type eq "mut") {
			
			$i = index($change,">");
			
			$bases = substr($change,($i+1));
	
			$origBases = substr($change,($i-1),1);
			
			$position = substr($change,0,($i-1));
								
			push @pos, $position;
			
			push @orig, $origBases;
			
			push @changes, $bases;						
			
		} else {
			
			die "Unknown type $type\n";

		}
		

		
	}
	
	%hash = ();

	$hash{'type'} = $type;

	$hash{'chr'} = $chr;

	$hash{'n'} = $n;

	$hash{'pos'} = \@pos;

	$hash{'orig'} = \@orig;
	
	$hash{'changes'} = \@changes;

	print "n=",$hash{'n'},"\ttype=",$hash{'type'},"\tchr=",$hash{'chr'},"\tpos=",@{$hash{'pos'}},"\torig=",@{$hash{'orig'}},"\tchanges=",@{$hash{'changes'}},"\n";
	
	
	return \%hash;

} #end sub procGenomicChange



############################

#this function reverse complements the given DNA sequence; if there is a space character 
#	(blank space, tab etc) anywhere in the sequence (usually at the end), it is removed from the 
#	final reverse complemented sequence

sub rev_com_remove_space{ #START REV_COM_REMOVE_SPACE

    my ($str,$len,$rev_com,$i,@array);

    ($str)=@_;

    $rev_com=undef;

    $len=length($str);

    $str=reverse($str);

    @array=split(//,$str);

    for($i=0;$i<$len;$i++){

	if($array[$i] eq "A" || $array[$i] eq "a"){

	    $rev_com=$rev_com."T";

	}elsif($array[$i] eq "C" || $array[$i] eq "c"){

	    $rev_com=$rev_com."G";

	}elsif($array[$i] eq "G" || $array[$i] eq "g"){

	    $rev_com=$rev_com."C";

	}elsif($array[$i] eq "T" || $array[$i] eq "t"){

	    $rev_com=$rev_com."A";

	}elsif($array[$i]=~/\s/){

	    #do nothing if the character is a blank space, tab etc

	}else{

	    $rev_com=$rev_com."$array[$i]";

	}


    }


    return $rev_com;

} #END REV_COM_REMOVE_SPACE

#######

sub getFirstNonEmptyPos { # start sub getFirstNonEmptyPos

	# function takes a sequence of symbols as input
	# returns the first position in the sequence that is non-empty
	# if the sequence is completely empty, returns -1

	my ($seq) = @_;
	
	my (@arr,$i,$found);
	
	$found = 0;
	
	@arr = split(//,$seq);
	
	for($i=0; $i<=$#arr; $i++){
				
		if($arr[$i] eq " "){
			
			next;

		} else{
			
			$found = 1;
			
			last;

		}
		
	}	

	if($found == 1){
		
		return $i;

	}
	else{
		
		return -1;
		
	}

} # end sub getFirstNonEmptyPos


#######

sub compareSeq { # start sub compareSeq

	# function compares two input sequences
	# input
		# two sequences of symbols seq1 and seq2
		# diff: difference character, usually "*"
		
	# output
		# a sequence which has " " for every position where the two sequences have 
		# identical sequences, diff character for every position that is different
		# length(compareLine) = length(longer of seq1 and seq2)

	my ($seq1,$seq2,$diff) = @_;

	my (@arr1,@arr2,$l1,$l2,$i,$compareLine,$l);

	@arr1 = split(//,$seq1);
	
	@arr2 = split(//,$seq2);
	
	$l1 = length($seq1);

	$l2 = length($seq2);

	$l = max($l1,$l2);
	
	$compareLine = "";
	
	for($i=0; $i < $l; $i++){
		
		if(($arr1[$i] eq $arr2[$i]) || 
			($arr1[$i] =~ /^$/ && $arr2[$i] !~ /^$/) ||
			($arr1[$i] !~ /^$/ && $arr2[$i] =~ /^$/)){
			
			$compareLine = $compareLine." ";
			
		} else {
			
			$compareLine = $compareLine.$diff;
			
		}
		
	}

	while($compareLine=~/\s$/){

		chop($compareLine);

	}

	return $compareLine;

} # end sub compareSeq

#######


sub codonMap { # start sub codonMap 

	# M == ATG; * == TAA, TAG, TGA
	
	my ($single) = @_;
	
	if(!($single == 0 || $single == 1)){
		
		die "in codonMap: single = $single\n";
		
	}
	
	my (%codonMap, %codonMapName);
	
	%codonMap = ();
	
	$codonMap{'TTT'} = 'F';
	$codonMap{'TTC'} = 'F';
	$codonMap{'TTA'} = 'L';
	$codonMap{'TTG'} = 'L';
	$codonMap{'TCT'} = 'S';
	$codonMap{'TCC'} = 'S';
	$codonMap{'TCA'} = 'S';
	$codonMap{'TCG'} = 'S';
	$codonMap{'TAT'} = 'Y';
	$codonMap{'TAC'} = 'Y';
	$codonMap{'TAA'} = '*';
	$codonMap{'TAG'} = '*';
	$codonMap{'TGT'} = 'C';
	$codonMap{'TGC'} = 'C';
	$codonMap{'TGA'} = '*';
	$codonMap{'TGG'} = 'W';
	$codonMap{'CTT'} = 'L';
	$codonMap{'CTC'} = 'L';
	$codonMap{'CTA'} = 'L';
	$codonMap{'CTG'} = 'L';
	$codonMap{'CCT'} = 'P';
	$codonMap{'CCC'} = 'P';
	$codonMap{'CCA'} = 'P';
	$codonMap{'CCG'} = 'P';
	$codonMap{'CAT'} = 'H';
	$codonMap{'CAC'} = 'H';
	$codonMap{'CAA'} = 'Q';
	$codonMap{'CAG'} = 'Q';
	$codonMap{'CGT'} = 'R';
	$codonMap{'CGC'} = 'R';
	$codonMap{'CGA'} = 'R';
	$codonMap{'CGG'} = 'R';
	$codonMap{'ATT'} = 'I';
	$codonMap{'ATC'} = 'I';
	$codonMap{'ATA'} = 'I';
	$codonMap{'ATG'} = 'M';
	$codonMap{'ACT'} = 'T';
	$codonMap{'ACC'} = 'T';
	$codonMap{'ACA'} = 'T';
	$codonMap{'ACG'} = 'T';
	$codonMap{'AAT'} = 'N';
	$codonMap{'AAC'} = 'N';
	$codonMap{'AAA'} = 'K';
	$codonMap{'AAG'} = 'K';
	$codonMap{'AGT'} = 'S';
	$codonMap{'AGC'} = 'S';
	$codonMap{'AGA'} = 'R';
	$codonMap{'AGG'} = 'R';
	$codonMap{'GTT'} = 'V';
	$codonMap{'GTC'} = 'V';
	$codonMap{'GTA'} = 'V';
	$codonMap{'GTG'} = 'V';
	$codonMap{'GCT'} = 'A';
	$codonMap{'GCC'} = 'A';
	$codonMap{'GCA'} = 'A';
	$codonMap{'GCG'} = 'A';
	$codonMap{'GAT'} = 'D';
	$codonMap{'GAC'} = 'D';
	$codonMap{'GAA'} = 'E';
	$codonMap{'GAG'} = 'E';
	$codonMap{'GGT'} = 'G';
	$codonMap{'GGC'} = 'G';
	$codonMap{'GGA'} = 'G';
	$codonMap{'GGG'} = 'G';
	
	$codonMapName{'TTT'} = 'Phe';
	$codonMapName{'TTC'} = 'Phe';
	$codonMapName{'TTA'} = 'Leu';
	$codonMapName{'TTG'} = 'Leu';
	$codonMapName{'TCT'} = 'Ser';
	$codonMapName{'TCC'} = 'Ser';
	$codonMapName{'TCA'} = 'Ser';
	$codonMapName{'TCG'} = 'Ser';
	$codonMapName{'TAT'} = 'Tyr';
	$codonMapName{'TAC'} = 'Tyr';
	$codonMapName{'TAA'} = 'Ter';
	$codonMapName{'TAG'} = 'Ter';
	$codonMapName{'TGT'} = 'Cys';
	$codonMapName{'TGC'} = 'Cys';
	$codonMapName{'TGA'} = 'Ter';
	$codonMapName{'TGG'} = 'Trp';
	$codonMapName{'CTT'} = 'Leu';
	$codonMapName{'CTC'} = 'Leu';
	$codonMapName{'CTA'} = 'Leu';
	$codonMapName{'CTG'} = 'Leu';
	$codonMapName{'CCT'} = 'Pro';
	$codonMapName{'CCC'} = 'Pro';
	$codonMapName{'CCA'} = 'Pro';
	$codonMapName{'CCG'} = 'Pro';
	$codonMapName{'CAT'} = 'His';
	$codonMapName{'CAC'} = 'His';
	$codonMapName{'CAA'} = 'Gln';
	$codonMapName{'CAG'} = 'Gln';
	$codonMapName{'CGT'} = 'Arg';
	$codonMapName{'CGC'} = 'Arg';
	$codonMapName{'CGA'} = 'Arg';
	$codonMapName{'CGG'} = 'Arg';
	$codonMapName{'ATT'} = 'Ile';
	$codonMapName{'ATC'} = 'Ile';
	$codonMapName{'ATA'} = 'Ile';
	$codonMapName{'ATG'} = 'Met';
	$codonMapName{'ACT'} = 'Thr';
	$codonMapName{'ACC'} = 'Thr';
	$codonMapName{'ACA'} = 'Thr';
	$codonMapName{'ACG'} = 'Thr';
	$codonMapName{'AAT'} = 'Asn';
	$codonMapName{'AAC'} = 'Asn';
	$codonMapName{'AAA'} = 'Lys';
	$codonMapName{'AAG'} = 'Lys';
	$codonMapName{'AGT'} = 'Ser';
	$codonMapName{'AGC'} = 'Ser';
	$codonMapName{'AGA'} = 'Arg';
	$codonMapName{'AGG'} = 'Arg';
	$codonMapName{'GTT'} = 'Val';
	$codonMapName{'GTC'} = 'Val';
	$codonMapName{'GTA'} = 'Val';
	$codonMapName{'GTG'} = 'Val';
	$codonMapName{'GCT'} = 'Ala';
	$codonMapName{'GCC'} = 'Ala';
	$codonMapName{'GCA'} = 'Ala';
	$codonMapName{'GCG'} = 'Ala';
	$codonMapName{'GAT'} = 'Asp';
	$codonMapName{'GAC'} = 'Asp';
	$codonMapName{'GAA'} = 'Glu';
	$codonMapName{'GAG'} = 'Glu';
	$codonMapName{'GGT'} = 'Gly';
	$codonMapName{'GGC'} = 'Gly';
	$codonMapName{'GGA'} = 'Gly';
	$codonMapName{'GGG'} = 'Gly';
	
	if($single){

		return \%codonMap;

	} else {
		
		return \%codonMapName;		
	}
	
} # end sub codonMap

#######

sub getCdnaFS1 { # start sub getCdnaFS1

	my ($ref,$posGenomicFS1) = @_;

	my (@exonsGenomicFS1,$i,$intron,$exon,@f,$exonStart,$exonEnd,$prevExonStart,$prevExonEnd,
		$intronLen,$intronLenTotal,$posCdnaFS1);

	@exonsGenomicFS1 = @{$ref};

	$intronLenTotal = 0;

	for($i = 0; $i <= $#exonsGenomicFS1; $i++){

		$exon = $exonsGenomicFS1[$i];

		@f = split(/-/,$exon);

		$exonStart = $f[0];

		$exonEnd = $f[1];

		if($posGenomicFS1 >= $exonStart & $posGenomicFS1 <= $exonEnd){

			if($i > 0){

				$intronLenTotal = $intronLenTotal + $exonStart - $prevExonEnd - 1;

			}

			last;

		}

		$intronLenTotal = $intronLenTotal + $exonStart - $prevExonEnd - 1;
	
		$prevExonStart = $exonStart;

		$prevExonEnd = $exonEnd;


	}

	$posCdnaFS1 = $posGenomicFS1 - $intronLenTotal;

	print "intronLenTotal = $intronLenTotal\n";

	return $posCdnaFS1;

} # end sub getCdnaFS1


#######

sub getGenomicCdsPosFS1{ # start sub getGenomicCdsPosFS1 

	# function takes the genomic FS1 coordinates of exons (encapsulated in exonsGenomicFS1) 
	# as input (as opposed to genomic coordinates taken by getGenomicPosFS1) 
	# and gets the FS1 position of the cds coordinate (usually cdsStart or cdsEnd)
	# Note that the cds coordinates are annotated wrt FS1 exons (starting from 1) but
	# without the introns
	# So this function just takes the cds position (which is always FS1, starting from 1) 
		# without the introns and calculates the new cds position accounting for the introns
	
	my ($ref,$strand_gaf,$cdsPos) = @_;
	
	my (@exonsGenomicFS1,$posFS1,$i,$exonFS1,$exonFS1Start,$exonFS1End,$exonFS1Len,@f,
		$totalLen,$cdsPos2);


	@exonsGenomicFS1 = @{$ref};

	#print "getGenomicCdsPosFS1: cdsPos = $cdsPos\n";

	if(!($strand_gaf eq "+" || $strand_gaf eq "-")){
		
		die "In getGenomicCdsPosFS1: strand_gaf = $strand_gaf\texonsGenomicFS1 = 
		@exonsGenomicFS1\n";

	}

	$totalLen = 0;

	for($i = 0; $i <= $#exonsGenomicFS1; $i++){
		
		$exonFS1 = $exonsGenomicFS1[$i];
		
		@f = split(/-/,$exonFS1);
		
		$exonFS1Start = $f[0];
		
		$exonFS1End = $f[1];
		
		$exonFS1Len = $exonFS1End - $exonFS1Start + 1;
	
		#print "exonFS1Len = $exonFS1Len\n";
			
		$totalLen = $totalLen + $exonFS1Len;
		
		if($totalLen >= $cdsPos){
			
			last;

		}

	}

	$totalLen = $totalLen - $exonFS1Len;
	
	$cdsPos2 = $cdsPos - $totalLen;

	$posFS1 = $exonFS1Start + $cdsPos2 - 1;
	
	return $posFS1;

} # end sub getGenomicCdsPosFS1

#######

sub getGenomicPosFS1{ # start sub getGenomicPosFS1 

	# function takes genomic coordinates of exons (encapsulated in coords_gaf) and 
	# gets the FS1 position of any genomic coordinate

	my ($coords_gaf,$strand_gaf,$pos) = @_;

	my (@f,@exonsGenomic,@exonArr,$exon,$subtract,$i,$posFS1,$firstTrPos,$lastTrPos);

	if(!($strand_gaf eq "+" || $strand_gaf eq "-")){
		
		die "In getGenomicPosFS1: strand_gaf = $strand_gaf\tcoords_gaf = $coords_gaf\n";

	}
	
	@f = split(/:/,$coords_gaf);
		
	@exonsGenomic = split(/,/,$f[1]);	

	# check if the position is within the transcript range
	
	@f = split(/-/,$exonsGenomic[0]);
	
	$firstTrPos = $f[0];
	
	@f = split(/-/,$exonsGenomic[$#exonsGenomic]);
	
	$lastTrPos = $f[1];
	
	
	if($pos < $firstTrPos || $pos > $lastTrPos){
		
		# this can happen when iterating through all transcripts for a gene; 
		# some transcripts may not have the specified position
		
		print "ERROR: getGenomicPosFS1: pos = $pos not in range of transcript \ 
		\ ($firstTrPos,$lastTrPos)\ncooords_gaf=$coords_gaf\n";

		return -1;
	}
	

	if($strand_gaf eq "-"){

		@exonsGenomic = reverse @exonsGenomic;
	
		$exon = $exonsGenomic[0];
			
		@exonArr = split(/-/,$exon);
				
		$subtract = $exonArr[1]; 

		$posFS1 = $subtract - $pos + 1;
	
	} else {
		
		$exon = $exonsGenomic[0];
		
		@exonArr = split(/-/,$exon);
				
		$subtract = $exonArr[0]; 

		$posFS1 = $pos - $subtract + 1;
		
	}

	return $posFS1;
	
} # end sub getGenomicPosFS1


#######

sub getGenomicExonsFS1{ # start sub getGenomicExonsFS1 

	# FS1 = > Forward strand, Start at 1

	#IMPORTANT: How to read the final exon coordinates (exonsGenomicFS1) on the genome

	# for negative strand:

	# chr11:125151236-125151933,125151935-125152623,125152979-125153107,125153657-125153680,125153827-125153924:-
	#	3'		2689  -  1992       1990  -  1302      946   -   818       268   -   245   ,     98   -   1    5'

	# for positive strand:

	#chr1:196148258-196148312,196153632-196153750,196155725-196155927,196157057-196157412,196163344-196163546,196164755-196165896:+  
	# 5'	  1	   -	55 	 	5375   -	5493     7468  -  7670       8800  -   9155      15087 -  15289     16498  -  17639  3'
				   				
	my ($coords_gaf,$strand_gaf) = @_;

	my (@f,@exonsGenomic,@exonsGenomicFS1,$i,$exon,@exonArr,$subtract,$exonStartFS1,$exonEndFS1,$exonFS1);

	if(!($strand_gaf eq "+" || $strand_gaf eq "-")){
		
		die "In getGenomicExonsFS1: coords_gaf=$coords_gaf\tstrand_gaf = $strand_gaf\n";

	}

	@f = split(/:/,$coords_gaf);
		
	@exonsGenomic = split(/,/,$f[1]);	

	@exonsGenomicFS1 = ();

	if($strand_gaf eq "-"){ # if strand_gaf is '-'

		@exonsGenomic = reverse @exonsGenomic;

		for($i = 0; $i <= $#exonsGenomic; $i++){
			
			$exon = $exonsGenomic[$i];
			
			@exonArr = split(/-/,$exon);
			
			if($i == 0){
				
				$subtract = $exonArr[1]; 

			}

			$exonStartFS1 = $subtract - $exonArr[1] + 1;
			
			$exonEndFS1 = $subtract - $exonArr[0] + 1;
	
			$exonFS1 = $exonStartFS1."-".$exonEndFS1;
			
			push @exonsGenomicFS1, $exonFS1;
			
		}


	} # end if strand_gaf is '-'

	else { # start if strand_gaf is '+'

		for($i = 0; $i <= $#exonsGenomic; $i++){
			
			$exon = $exonsGenomic[$i];
			
			@exonArr = split(/-/,$exon);
			
			if($i == 0){
				
				$subtract = $exonArr[0]; 

			}

			$exonStartFS1 = $exonArr[0] - $subtract + 1;
			
			$exonEndFS1 = $exonArr[1] - $subtract + 1;
	
			$exonFS1 = $exonStartFS1."-".$exonEndFS1;
			
			push @exonsGenomicFS1, $exonFS1;
			
		}


	} # end if strand_gaf if '+'

	#print "exonsGenomic = @exonsGenomic\n";

	#print "exonsGenomicFS1 = @exonsGenomicFS1\n";


	return \@exonsGenomicFS1;


} # end sub getGenomicExonsFS1

#######

sub trPosition{ # start sub trPosition
	
	# this function gets the position of a given base (in genomic coordinates) on the
	# corresponding transcript (forward strand, without introns) counting from the 1st 
	# position of the first exon that is transcribed
	
	# input:
		# tr: id of the transcript (uc...)
		# pos: base position within the transcript (genomic coordinates)
	
	my ($tr,$pos,$genomeDir,$dbh,$hgVersion) = @_;

	my ($coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,
		$strand_gaf,$cdsStart_gaf,$cdsEnd_gaf,@exonsGenomicFS1,$posFS1,$i,$l,$newPos);
	
	
	my ($exonStart,$exonEnd,@f,$found);
	
	($coords_gaf,$featCoords_gaf,$type_gaf,$chr_gaf,$start_gaf,$end_gaf,
		$strand_gaf,$cdsStart_gaf,$cdsEnd_gaf) = @{getGafAnnotation($tr,$dbh,$hgVersion)};

	# get the FS1 base positions
	
	@exonsGenomicFS1 = @{getGenomicExonsFS1($coords_gaf,$strand_gaf)};
	
	#print "trPosition: calling getGenomicPosFS1:\n";
	
	$posFS1 = getGenomicPosFS1($coords_gaf,$strand_gaf,$pos);
	
	#print "trPosition:\tcoords_gaf = $coords_gaf\n\texonsGenomicFS1 = @exonsGenomicFS1\n";
	#print "\tpos = $pos\n\tposFS1 = $posFS1\n";
	
	$newPos = -1;
	
	$found = 0;
	
	for($i = 0; $i <= $#exonsGenomicFS1; $i++){
		
		@f = split(/-/,$exonsGenomicFS1[$i]);
		
		$exonStart = $f[0];
		
		$exonEnd = $f[1];
		
		#print "\texonStart = $exonStart\texonEnd = $exonEnd\n";
		
		if($posFS1 >= $exonStart && $posFS1 <= $exonEnd){
			
			$found = 1;
			
			if($i == 0){

				$newPos = $posFS1 - $exonStart + 1;
				
				
			}else {

				$newPos = $newPos + $posFS1 - $exonStart + 1;
	
			}
			last;
					
		} else {
			
			if($i == 0){
	
				$newPos = $exonEnd - $exonStart + 1;
				
			} else {	
	
				$newPos = $newPos + $exonEnd - $exonStart + 1;

			}
		}
		
		
	}
	
	if($found == 0){
		
		die "ERROR: trPos: not found tr = $tr\tpos = $pos\n";

	}

	return $newPos;
	
} # end sub trPosition

#######

sub getCdnaSeq{ # start sub getCdnaSeq

	# function gets the sequence of the input transcript sequence
	# the following are the inputs
		# id_o: UCSC transcript id of the form uc....
		# dbh: 
			# if cdsStart is -1, it means that the cds start position is not available
	
	# the function returns
		# seq: the complete sequence of the transcript
		# seq2: the transcript sequence starting from the cds start position
			# if cdsStart == -1, seq2 = -1
			

	my ($tr1,$dbh,$hgVersion,$genomeDir) = @_;

	my ($seq,$seq2,@arr);

	my ($coords_gaf1,$featCoords_gaf1,$type_gaf1,$chr_gaf1,$start_gaf1,$end_gaf1,
		$strand_gaf1,$cdsStart_gaf1,$cdsEnd_gaf1);

	my ($i,%hash,$start,$end,$strand,$cdsStartFS1_tr1,@exonsGenomicFS1_tr1);
	
	my (@f,@exonsGenomic1,@exonArr,$exonStart,$exonEnd,$exonLen,$totalLen,$exonSeq,$reverse);
	
	# get gaf annotation for the transcript (_gaf)

	($coords_gaf1,$featCoords_gaf1,$type_gaf1,$chr_gaf1,$start_gaf1,$end_gaf1,
		$strand_gaf1,$cdsStart_gaf1,$cdsEnd_gaf1) = @{getGafAnnotation($tr1,$dbh,$hgVersion)};
	
	# get the FS1 junction and cds start positions for tr1
	
	@exonsGenomicFS1_tr1 = @{getGenomicExonsFS1($coords_gaf1,$strand_gaf1)};

	$cdsStartFS1_tr1 = getGenomicCdsPosFS1(\@exonsGenomicFS1_tr1,$strand_gaf1,
		$cdsStart_gaf1);

	# get the exons for the transcript

	@f = split(/:/,$coords_gaf1);

	print "getCdnaSeq: exons = ",@f,"\n";
		
	@exonsGenomic1 = split(/,/,$f[1]);

	@exonArr = ();

	if($strand_gaf1 eq "+"){  # if strand of tr1 is positive
		
		for($i = 0;$i <= $#exonsGenomic1; $i++){ # start iterating through exons of tr1
			
			@f = split(/-/,$exonsGenomic1[$i]);
			
			$exonStart = $f[0];
			
			$exonEnd = $f[1];
								
			%hash = ();
				
			$hash{'start'} = $exonStart;

			$hash{'end'} = $exonEnd;
				
			$hash{'strand'} = $strand_gaf1;
				
				
			push @exonArr, { %hash };
											
		} # finish iterating through exons of tr1
		
	
	} else { # if strand of tr1 is negative
				
		# note: this reverses the exon boundary pairs, so that for every exon, 
		# start is still < end

		@exonsGenomic1 = reverse @exonsGenomic1;
		
		for($i = 0;$i <= $#exonsGenomic1; $i++){ # start iterating through exons of tr1
			
			@f = split(/-/,$exonsGenomic1[$i]);
			
			$exonStart = $f[0];
			
			$exonEnd = $f[1];
				
			%hash = ();
				
			$hash{'start'} = $exonStart;

			$hash{'end'} = $exonEnd;
				
			$hash{'strand'} = $strand_gaf1;
								
			push @exonArr, { %hash };								
				
			
		} # finish iterating through exons of tr1
								
	} # end if strand of tr1 is negative
	

	# create the transcript
	
	$seq = ();

		
	for($i = 0; $i <= $#exonArr; $i++){ # start iterating through each exon entry
		
		%hash = %{$exonArr[$i]};
		
		$start = $hash{'start'};
		
		$end = $hash{'end'};
		
		$strand = $hash{'strand'};
						
		$reverse = 0;
		
		if($strand eq "-"){
			
			$reverse = 1;
		}
		
		$exonLen = $end - $start + 1;
		
		$totalLen = $totalLen + $exonLen;
			
		$exonSeq = getGenomicSeq($chr_gaf1,$start,$end,$reverse,$genomeDir,0);
		
		$seq = $seq.$exonSeq;
				
		print "$start\t$end\t$strand\t$chr_gaf1\t$exonLen\t$totalLen\n";		
		
	} # finish iterating through each exon entry	

	 if($cdsStart_gaf1 == -1){

		$seq2 = -1;

	} else{

		$seq2 = substr($seq,$cdsStart_gaf1-1);

	}

	@arr = ($seq,$seq2);

	return \@arr;

} # end sub getCdnaSeq	

#######

sub getCdnaSeqOld{ # start sub getCdnaSeqOld

	# function gets the sequence of the input transcript sequence
	# the following are the inputs
		# id_o: UCSC transcript id of the form uc....
		# cdsStart: cds start position, 0-base
			# if cdsStart is -1, it means that the cds start position is not available
	
	# the function returns
		# seq: the complete sequence of the transcript
		# seq2: the transcript sequence starting from the cds start position
			# if cdsStart == -1, seq2 = -1
			
	# this was retired on 022014. An inconsistency was found:
	#  the sequence of uc010tay.1 is inconsistent between
	#vim /xchip/cga/reference/annotation/db/ucsc/GAF_hg19/GAF_bundle/outputs/UCSCgene.Dec2009.fa
	#and
	#if you try and assemble it from exons of
	#/cga/wu/sachet/hla:
	#sqlite3 gaf_coords.db
	#.output genes_hg19.txt
	#select * from coords_hg19 where id like 'uc010tay.1%' and source!='calculated';
	#.exit
	#The AGCAGCGGCAGCAGCGGCAGCAGC sequence is found in the former but not in the latter.
	#Modify getCdnaSeq function in common_functions_hla.pl to build the cDNA sequence by assembling exons.

			
	my ($id_o,$cdsStart,$hgVersion) = @_;

	my (%gene_fasta_db,$seq,$seq2,@arr);
	
	# get sequence of the transcript
	
	if($hgVersion eq "hg18"){
	
		tie (%gene_fasta_db, "DB_File", "/cga/wu/sachet/hla/gene.fasta.db") ||
			die ("Cannot open /cga/wu/sachet/hla/gene.fasta.db");

	} elsif($hgVersion eq "hg19"){
	
		tie (%gene_fasta_db, "DB_File", "/cga/wu/sachet/hla/gene.fasta.hg19.db") ||
			die ("Cannot open /cga/wu/sachet/hla/gene.fasta.hg19.db");

	}

	$seq = $gene_fasta_db{$id_o};

	#print "seq=$seq\n";

	untie(%gene_fasta_db);


	# get sequence of the transcript starting at the start codon

	if($cdsStart == -1){
		
		$seq2 = -1;
		
	} else{

		$seq2 = substr($seq,$cdsStart);

	}
	
	@arr = ($seq,$seq2);
	
	return \@arr;
	

} # end sub getCdnaSeqOld


#######

sub getGenomicSeq{ # start sub getGenomicSeq

	# if reverse == 1, reverse complement
	#			 == 0, don't

	my ($chr,$start,$end,$reverse,$genomeDir,$addChr) =  @_;

	my ($file,$seq,$len);
	
	#print "getGenomicSeq: chr=$chr\tstart=$start\tend=$end\treverse=$reverse\t";
	#print "genomeDir=$genomeDir\n";
	
	if($start > $end){
		
		die "in getGenomicSeq: start = $start is > end = $end\n";
		
	}
	
	$len = $end - $start + 1;
	 
	if($addChr == 1){

		$file = $genomeDir."/chr".$chr.".txt";

	} else {

		$file = $genomeDir."/".$chr.".txt";
		
	}

	#print "file=$file\n";
	
	open FILE, $file || die "Cannot open $file";

	seek(FILE,$start-1,0); #Note: this is base 0
		
	read(FILE,$seq,$len);

	close FILE;

	if($reverse == 1){
		
		$seq = rev_com_remove_space($seq);

	}

	#print "getGenomicSeq: seq=$seq\n";
	
	return $seq;

} # end getGenomicSeq

#######

sub getRegionAroundWindow{ # start sub getRegionAroundWindow
	
	# function gets the region around a specified index and window in a set of
	# input sequences
	# the total returned length (per input sequence) = window1 + 1 + window2
	# input
		# @arr1: a set of sequences to be processed
		# index: the position around which to fetch the region, 0-base
		# window1: window length on the left of the index
		# window2: window length on the right of the index 
	
	my ($arrRef,$index,$window1,$window2) = @_;
	
	my ($s1,$s2,$i,@arr2,$seq,$seq2,@arr1);
	
	@arr1 = @{$arrRef};


	if($index==-1){
		
		return -1;
		
	}

	for($i=0; $i<=$#arr1; $i++){
		
		$seq = $arr1[$i];
		
		if($index >= $window1){
	
			$s1 = substr($seq,$index - $window1, $window1);
	
		} else {
		
			$s1 = substr($seq,0, $index);
				
		}

		$s2 = substr($seq,$index,$window2 + 1);
		
		$seq2 = $s1.$s2;
		
		$arr2[$i] = $seq2;
				
		
	}

	return \@arr2;
	
} # end sub getRegionAroundWindow


###########################################

#function returns 1 if the name is found in the array;0 otherwise

#int found_arr(name,\array)

sub found_arr{ #START FOUND_ARR

    my ($fa_name,$fa_x1)=@_;

    my (@fa_name_arr,$fa_i,$fa_found);

    @fa_name_arr=@{$fa_x1};

    $fa_found=0;

    for($fa_i=0;$fa_i<=$#fa_name_arr;$fa_i++){ #START FA FOR 1

        if($fa_name eq $fa_name_arr[$fa_i]){

            $fa_found=1;

            return $fa_found;

        }

    } #END FA FOR 1

    return $fa_found;

} #END FOUND_ARR

#######

sub overlap_coords{ # start sub overlap_coords
	
	my ($s1,$e1,$s2,$e2) = @_;
	
	my ($overlap,$overlapCount,$i,@arr);
	
	$overlap = 0;
	
	$overlapCount = 0;
	
	if($e1 < $s1 || $e2 < $s2){
		
		die "in overlap_coords: s1 = $s1\te1 = $e1\ts2 = $s2\te2 = $e2\n";
	}

	if(!($e2 < $s1 || $s2 > $e1)){
		
		$overlap = 1;
	
		for($i = $s2; $i <= $e2; $i++){
			
			if($i >= $s1 && $i <= $e1){
				
				$overlapCount++;
			}
			
		}	
		
	}
	
	@arr = ($overlap,$overlapCount);
	
	return \@arr;
	
} # end sub overlap_coords


#######

sub rev_com_remove_space{ #START REV_COM_REMOVE_SPACE

    my ($str,$len,$rev_com,$i,@array);

    ($str)=@_;

    $rev_com=undef;

    $len=length($str);

    $str=reverse($str);

    @array=split(//,$str);

    for($i=0;$i<$len;$i++){

	if($array[$i] eq "A" || $array[$i] eq "a"){

	    $rev_com=$rev_com."T";

	}elsif($array[$i] eq "C" || $array[$i] eq "c"){

	    $rev_com=$rev_com."G";

	}elsif($array[$i] eq "G" || $array[$i] eq "g"){

	    $rev_com=$rev_com."C";

	}elsif($array[$i] eq "T" || $array[$i] eq "t"){

	    $rev_com=$rev_com."A";

	}elsif($array[$i]=~/\s/){

	    #do nothing if the character is a blank space, tab etc

	}else{

	    $rev_com=$rev_com."$array[$i]";

	}


    }


    return $rev_com;

} #END REV_COM_REMOVE_SPACE



###########################################




1;
